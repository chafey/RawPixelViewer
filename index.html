<!DOCTYPE html>
<html>
  <head>
    <!-- twitter bootstrap CSS stylesheet - not required by cornerstone -->
    <link
      href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css"
      rel="stylesheet"
    />
  </head>
  <body>
    <div class="container">
      <h1>RawPixelViewer</h1>
      Drag and drop a file containing raw pixel data to the image display area (black
      box) below to view it.
      <br />
      You can adjust the image properties before or after the raw pixel data is
      dropped.
      <br />
      You can adjust the window center/width by dragging the cursor (e.g. left
      mouse button drag)
      <br />

      <br />
      <form class="form-inline" role="form">
        <div class="form-group">
          <label>Width</label>
          <input id="width" type="text" placeholder="e.g. 512" value="512" />
        </div>
        <div class="form-group">
          <label>Height</label>
          <input id="height" type="text" placeholder="e.g. 512" value="512" />
        </div>
        <div class="form-group">
          <label>Component Size (bits)</label>
          <input id="pixelSize" type="text" placeholder="e.g. 16" value="16" />
        </div>
        <div class="form-group">
          <label for="signedness">Signedness</label>
          <select id="signedness" class="form-select">
            <option selected>Signed</option>
            <option>Unsigned</option>
          </select>
        </div>
        <div class="form-group">
          <label for="pixelFormat">Pixel Format</label>
          <select id="pixelFormat" class="form-select">
            <option selected>Grayscale</option>
            <option>RGB</option>
          </select>
        </div>
      </form>
      <div
        id="dicomImage"
        style="width: 512px; height: 512px"
        oncontextmenu="return false"
        onmousedown="return false"
      ></div>
    </div>
  </body>

  <!-- include the cornerstone library -->
  <script src="https://unpkg.com/cornerstone-core/dist/cornerstone.min.js"></script>
  <script>
    window.cornerstone ||
      document.write(
        '<script src="https://unpkg.com/cornerstone-core">\x3C/script>'
      );
  </script>

  <script>
    let rawPixelData = new ArrayBuffer(512 * 512 * 2 * 4);

    // image enable the element
    const element = document.getElementById("dicomImage");
    cornerstone.enable(element);

    const getMinMax = (buffer) => {
      const result = {
        min: 65535,
        max: -65535,
      };

      for (let i = 0; i < buffer.length; i++) {
        if (buffer[i] > result.max) {
          result.max = buffer[i];
        }
        if (buffer[i] < result.min) {
          result.min = buffer[i];
        }
      }
      return result;
    };

    const getHistogram = (width, height, pixelData, minMax) => {
      const histogram = [];
      const dynamicRange = minMax.max - minMax.min;
      for (let i = 0; i <= dynamicRange; i++) {
        histogram[i] = 0;
      }
      const hOffset = width / 4 ;
      const vOffset = height / 4;
      let numPixels = 0;
      for (let y = vOffset; y < height - vOffset; y++) {
        for (let x = hOffset; x < width - hOffset; x++) {
          const index = y * width + x;
          const pixel = pixelData[index];
          const bin = pixel - minMax.min;
          histogram[bin]++;
          numPixels++;
        }
      }

      let firstBin = 0;
      for (; firstBin < dynamicRange; firstBin++) {
        if (histogram[firstBin]) {
          break;
        }
      }
      let lastBin = dynamicRange;
      for (; lastBin >= 0; lastBin--) {
        if (histogram[lastBin]) {
          break;
        }
      }
      let midBin = 0;
      let pixelCount = 0;
      for (; midBin < dynamicRange; midBin++) {
        pixelCount += histogram[midBin];
        if (pixelCount > numPixels / 2) {
          break;
        }
      }

      return {
        histogram,
        numPixels,
        firstBin,
        lastBin,
        midBin,
      };
    };

    const guessWWWC = (width, height, pixelData, minMax, bytesPerComponent) => {
      if(bytesPerComponent === 1) {
        return {
          windowWidth: 256,
          windowCenter: 127
        }
      }
      const histogram = getHistogram(width, height, pixelData, minMax);
      const windowWidth = histogram.lastBin - histogram.firstBin;

      return {
        windowWidth: windowWidth,
        windowCenter: histogram.midBin + minMax.min,
      };
    };

    const guessAttributesFromFileSize = (fileSize) => {
      if (fileSize == 524288) {
        // CT or MR
        return {
          width: 512,
          height: 512,
          pixelSize: 16,
          signed: true,
          pixelFormat: "Grayscale",
        };
      } else if (fileSize === 2097152) {
        // XA
        return {
          width: 1024,
          height: 1024,
          pixelSize: 16,
          signed: true,
          pixelFormat: "Grayscale",
        };
      } else if (fileSize === 921600) {
        // US
        return {
          width: 640,
          height: 480,
          pixelSize: 8,
          signed: false,
          pixelFormat: "RGB",
        };
      }
    };

    const getPixelData = (
      width,
      height,
      bytesPerComponent,
      componentsPerPixel,
      signed
    ) => {
      // special case for RGB data
      if (
        componentsPerPixel === 3 &&
        bytesPerComponent === 1 &&
        signed === false
      ) {
        const pixelData = new Uint8Array(width * height * 4);
        const rawPixelDataAsUint8 = new Uint8Array(rawPixelData);
        let pixelDataIndex = 0;
        let rawPixelDataIndex = 0;
        for (let numPixels = 0; numPixels < width * height; numPixels++) {
          pixelData[pixelDataIndex++] =
            rawPixelDataAsUint8[rawPixelDataIndex++];
          pixelData[pixelDataIndex++] =
            rawPixelDataAsUint8[rawPixelDataIndex++];
          pixelData[pixelDataIndex++] =
            rawPixelDataAsUint8[rawPixelDataIndex++];
          pixelData[pixelDataIndex++] = 255; // Alpha channel
        }
        return pixelData;
      }
      if (signed) {
        if (bytesPerComponent === 1) {
          return new Int8Array(rawPixelData);
        } else {
          return new Int16Array(rawPixelData);
        }
      } else {
        if (bytesPerComponent === 1) {
          return new Uint8Array(rawPixelData);
        } else {
          return new Uint16Array(rawPixelData);
        }
      }
    };

    const updateImage = () => {
      const width = parseInt(document.getElementById("width").value);
      const height = parseInt(document.getElementById("height").value);
      const pixelSize = parseInt(document.getElementById("pixelSize").value);
      const signed = document.getElementById("signedness").value === "Signed";
      const pixelFormat = document.getElementById("pixelFormat").value;
      const componentsPerPixel = pixelFormat === "RGB" ? 3 : 1;
      const bytesPerComponent = pixelSize <= 8 ? 1 : 2;

      let pixelData = getPixelData(
        width,
        height,
        bytesPerComponent,
        componentsPerPixel,
        signed
      );

      const minMax = getMinMax(pixelData);

      const wwwc = guessWWWC(width, height, pixelData, minMax, bytesPerComponent);

      const minPixelValue = minMax.min;
      const maxPixelValue = minMax.max;

      const image = {
        imageId: Math.random(),
        minPixelValue: minPixelValue,
        maxPixelValue: maxPixelValue,
        slope: 1.0,
        intercept: 0,
        windowCenter: wwwc.windowCenter,
        windowWidth: wwwc.windowWidth,
        render:
          componentsPerPixel === 3
            ? cornerstone.renderColorImage
            : cornerstone.render,
        getPixelData: () => {
          return pixelData;
        },
        rows: height,
        columns: width,
        height: height,
        width: width,
        color: pixelFormat == "RGB",
        columnPixelSpacing: 0.8984375,
        rowPixelSpacing: 0.8984375,
        sizeInBytes: rawPixelData.byteLength
      };
      cornerstone.displayImage(element, image);
      let viewport = cornerstone.getViewport(element);
      viewport.voi.windowWidth = wwwc.windowWidth;
      viewport.voi.windowCenter = wwwc.windowCenter;
      cornerstone.setViewport(element, viewport);
    };

    hookElementChanged = (id) => {
      document.getElementById(id).addEventListener("change", (event) => {
        updateImage();
      });
    };
    hookElementChanged("width");
    hookElementChanged("height");
    hookElementChanged("pixelSize");
    hookElementChanged("signedness");
    hookElementChanged("pixelFormat");

    // load the image and display it
    updateImage();

    // add event handlers to mouse move to adjust window/center
    element.addEventListener("mousedown", function (e) {
      let lastX = e.pageX;
      let lastY = e.pageY;

      function mouseMoveHandler(e) {
        const deltaX = e.pageX - lastX;
        const deltaY = e.pageY - lastY;
        lastX = e.pageX;
        lastY = e.pageY;

        let viewport = cornerstone.getViewport(element);
        viewport.voi.windowWidth += deltaX / viewport.scale;
        viewport.voi.windowCenter += deltaY / viewport.scale;
        cornerstone.setViewport(element, viewport);
      }

      function mouseUpHandler() {
        document.removeEventListener("mousemove", mouseMoveHandler);
        document.removeEventListener("mouseup", mouseUpHandler);
      }

      document.addEventListener("mousemove", mouseMoveHandler);
      document.addEventListener("mouseup", mouseUpHandler);
    });

    // this function gets called once the user drops the file onto the div
    function handleFileSelect(evt) {
      evt.stopPropagation();
      evt.preventDefault();

      // Get the FileList object that contains the list of files that were dropped
      var files = evt.dataTransfer.files;

      // this UI is only built for a single file so just dump the first one
      var file = files[0];
      console.log(file);

      var fileReader = new FileReader();
      fileReader.onload = function (e) {
        rawPixelData = e.target.result;
        const attrs = guessAttributesFromFileSize(file.size);
        console.log(attrs);
        if (attrs) {
          document.getElementById("width").value = attrs.width;
          document.getElementById("height").value = attrs.height;
          document.getElementById("pixelSize").value = attrs.pixelSize;
          document.getElementById("signedness").value = attrs.signed
            ? "Signed"
            : "Unsigned";
          document.getElementById("pixelFormat").value = attrs.pixelFormat;
        }
        updateImage();
      };
      fileReader.readAsArrayBuffer(file);
    }

    function handleDragOver(evt) {
      evt.stopPropagation();
      evt.preventDefault();
      evt.dataTransfer.dropEffect = "copy"; // Explicitly show this is a copy.
    }

    // Setup the dnd listeners.
    var dropZone = document.getElementById("dicomImage");
    dropZone.addEventListener("dragover", handleDragOver, false);
    dropZone.addEventListener("drop", handleFileSelect, false);
  </script>
</html>
